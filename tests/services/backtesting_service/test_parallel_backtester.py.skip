"""
Tests for parallel backtesting functionality.
"""

import pytest
import pandas as pd
import numpy as np
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime, timedelta

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from services.parallel_backtester import (
    ParallelBacktester, run_parallel_backtests, _run_single_backtest
)


class TestParallelBacktester:
    """Test parallel backtester functionality."""
    
    def test_initialization(self):
        """Test ParallelBacktester initialization."""
        symbols = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT']
        
        backtester = ParallelBacktester(
            symbols=symbols,
            exchange='binance',
            timeframe='1h',
            initial_capital=10000
        )
        
        assert backtester.symbols == symbols
        assert backtester.exchange == 'binance'
        assert backtester.timeframe == '1h'
        assert backtester.initial_capital == 10000
        assert backtester.max_workers > 0
    
    def test_initialization_with_custom_workers(self):
        """Test initialization with custom worker count."""
        backtester = ParallelBacktester(
            symbols=['BTC/USDT'],
            max_workers=4
        )
        
        assert backtester.max_workers == 4
    
    def test_aggregate_results_no_successful(self):
        """Test aggregating results when all backtests fail."""
        backtester = ParallelBacktester(symbols=['BTC/USDT', 'ETH/USDT'])
        
        results = [
            {'symbol': 'BTC/USDT', 'success': False, 'error': 'Test error'},
            {'symbol': 'ETH/USDT', 'success': False, 'error': 'Test error'}
        ]
        
        aggregated = backtester._aggregate_results(results, 10.0)
        
        assert aggregated['summary']['successful'] == 0
        assert aggregated['summary']['failed'] == 2
        assert aggregated['aggregated_metrics'] is None
        assert 'error' in aggregated
    
    def test_aggregate_results_with_successful(self):
        """Test aggregating results with successful backtests."""
        backtester = ParallelBacktester(symbols=['BTC/USDT', 'ETH/USDT'])
        
        results = [
            {
                'symbol': 'BTC/USDT',
                'success': True,
                'metrics': {
                    'total_trades': 10,
                    'winning_trades': 6,
                    'losing_trades': 4,
                    'win_rate': 60.0,
                    'profit_factor': 1.5,
                    'sharpe_ratio': 1.2,
                    'return_pct': 15.5,
                    'max_drawdown': 8.0
                }
            },
            {
                'symbol': 'ETH/USDT',
                'success': True,
                'metrics': {
                    'total_trades': 8,
                    'winning_trades': 5,
                    'losing_trades': 3,
                    'win_rate': 62.5,
                    'profit_factor': 1.8,
                    'sharpe_ratio': 1.5,
                    'return_pct': 20.0,
                    'max_drawdown': 6.0
                }
            }
        ]
        
        aggregated = backtester._aggregate_results(results, 15.0)
        
        assert aggregated['summary']['successful'] == 2
        assert aggregated['summary']['failed'] == 0
        assert aggregated['aggregated_metrics']['total_trades_all_symbols'] == 18
        assert aggregated['aggregated_metrics']['total_winning_trades'] == 11
        assert aggregated['aggregated_metrics']['total_losing_trades'] == 7
        assert 'average_win_rate' in aggregated['aggregated_metrics']
        assert 'best_symbol' in aggregated
        assert 'worst_symbol' in aggregated
    
    def test_get_best_symbol(self):
        """Test getting best performing symbol."""
        backtester = ParallelBacktester(symbols=['BTC/USDT', 'ETH/USDT'])
        
        results = [
            {
                'symbol': 'BTC/USDT',
                'success': True,
                'metrics': {'return_pct': 15.0, 'win_rate': 60.0, 'sharpe_ratio': 1.2}
            },
            {
                'symbol': 'ETH/USDT',
                'success': True,
                'metrics': {'return_pct': 25.0, 'win_rate': 65.0, 'sharpe_ratio': 1.5}
            }
        ]
        
        best = backtester._get_best_symbol(results)
        
        assert best['symbol'] == 'ETH/USDT'
        assert best['return_pct'] == 25.0
    
    def test_get_worst_symbol(self):
        """Test getting worst performing symbol."""
        backtester = ParallelBacktester(symbols=['BTC/USDT', 'ETH/USDT'])
        
        results = [
            {
                'symbol': 'BTC/USDT',
                'success': True,
                'metrics': {'return_pct': 15.0, 'win_rate': 60.0, 'sharpe_ratio': 1.2}
            },
            {
                'symbol': 'ETH/USDT',
                'success': True,
                'metrics': {'return_pct': 25.0, 'win_rate': 65.0, 'sharpe_ratio': 1.5}
            }
        ]
        
        worst = backtester._get_worst_symbol(results)
        
        assert worst['symbol'] == 'BTC/USDT'
        assert worst['return_pct'] == 15.0
    
    @patch('src.parallel_backtester.ProcessPoolExecutor')
    @patch('src.parallel_backtester._run_single_backtest')
    def test_run_parallel_backtests(self, mock_run_single, mock_executor):
        """Test running parallel backtests."""
        # Mock the executor
        mock_future = MagicMock()
        mock_future.result.return_value = {
            'symbol': 'BTC/USDT',
            'success': True,
            'metrics': {
                'total_trades': 10,
                'winning_trades': 6,
                'losing_trades': 4,
                'win_rate': 60.0,
                'return_pct': 15.0
            },
            'trades': []
        }
        
        mock_executor_instance = MagicMock()
        mock_executor_instance.__enter__.return_value = mock_executor_instance
        mock_executor_instance.__exit__.return_value = None
        mock_executor_instance.submit.return_value = mock_future
        mock_executor.return_value = mock_executor_instance
        
        # Mock as_completed to return the future
        with patch('src.parallel_backtester.as_completed') as mock_as_completed:
            mock_as_completed.return_value = [mock_future]
            
            backtester = ParallelBacktester(symbols=['BTC/USDT'])
            result = backtester.run_parallel_backtests()
            
            assert result['summary']['total_symbols'] == 1
            assert result['summary']['successful'] >= 0
    
    @patch('src.parallel_backtester.PARALLEL_BACKTESTING_ENABLED', False)
    def test_run_sequential_when_parallel_disabled(self):
        """Test that sequential mode is used when parallel is disabled."""
        with patch('src.parallel_backtester._run_single_backtest') as mock_run:
            mock_run.return_value = {
                'symbol': 'BTC/USDT',
                'success': True,
                'metrics': {'total_trades': 10, 'return_pct': 15.0},
                'trades': []
            }
            
            backtester = ParallelBacktester(symbols=['BTC/USDT'])
            result = backtester.run_parallel_backtests()
            
            assert result['summary']['total_symbols'] == 1
            mock_run.assert_called_once()


class TestSingleBacktest:
    """Test single backtest worker function."""
    
    @patch('src.backtester.Backtester')
    def test_run_single_backtest_success(self, mock_backtester_class):
        """Test successful single backtest."""
        # Mock backtester instance
        mock_backtester = MagicMock()
        mock_backtester.run_backtest.return_value = {
            'total_trades': 10,
            'win_rate': 60.0,
            'return_pct': 15.0
        }
        mock_backtester.trades = []
        mock_backtester_class.return_value = mock_backtester
        
        args = ('BTC/USDT', 'binance', '1h', datetime.now(), datetime.now(), 10000)
        result = _run_single_backtest(args)
        
        assert result['symbol'] == 'BTC/USDT'
        assert result['success']
        assert result['metrics'] is not None
        assert result['error'] is None
    
    @patch('src.backtester.Backtester')
    def test_run_single_backtest_failure(self, mock_backtester_class):
        """Test failed single backtest."""
        # Mock backtester to raise exception
        mock_backtester_class.side_effect = Exception("Test error")
        
        args = ('BTC/USDT', 'binance', '1h', datetime.now(), datetime.now(), 10000)
        result = _run_single_backtest(args)
        
        assert result['symbol'] == 'BTC/USDT'
        assert not result['success']
        assert result['metrics'] is None
        assert result['error'] == "Test error"


class TestConvenienceFunction:
    """Test convenience function for parallel backtesting."""
    
    @patch('src.parallel_backtester.ParallelBacktester')
    def test_run_parallel_backtests_function(self, mock_class):
        """Test run_parallel_backtests convenience function."""
        mock_instance = MagicMock()
        mock_instance.run_parallel_backtests.return_value = {'summary': {}}
        mock_class.return_value = mock_instance
        
        symbols = ['BTC/USDT', 'ETH/USDT']
        result = run_parallel_backtests(
            symbols=symbols,
            exchange='binance',
            timeframe='1h',
            initial_capital=10000
        )
        
        mock_class.assert_called_once()
        mock_instance.run_parallel_backtests.assert_called_once()
        assert 'summary' in result


if __name__ == "__main__":
    pytest.main([__file__, '-v'])
