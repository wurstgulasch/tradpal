#!/usr/bin/env python3
"""
Test the best Discovery configuration in backtest mode
"""

import sys
import os
import json
import tempfile
import pandas as pd
sys.path.insert(0, os.path.dirname(__file__))

# Modify settings BEFORE importing anything else
import config.settings as settings

# Disable ML for traditional backtesting to avoid feature mismatch errors
settings.ML_ENABLED = False

# Backup original values
original_config_mode = settings.CONFIG_MODE
original_adaptive_config_file = settings.ADAPTIVE_CONFIG_FILE
original_ml_enabled = settings.ML_ENABLED

from main import calculate_buy_hold_performance

def main():
    print('üß™ Testing Best Discovery Configuration in Backtest Mode')
    print('Configuration: EMA[49,187], RSI(20), BB(24), ADX')
    print('Symbol: BTC/USDT, Timeframe: 1h')
    print()

    # Load the best configuration from discovery results
    try:
        with open('output/discovery_results.json', 'r') as f:
            discovery_data = json.load(f)

        # Get the best configuration (first result)
        best_config = discovery_data['top_configurations'][0]['configuration']
        print('‚úÖ Loaded best configuration from discovery results')
        print(f'Fitness: {discovery_data["top_configurations"][0]["fitness_score"]:.2f}')
        print(f'P&L: {discovery_data["top_configurations"][0]["total_pnl_percent"]:.2f}%')
        print()

    except Exception as e:
        print(f'‚ùå Could not load discovery results: {e}')
        # Fallback to manually defined best config
        best_config = {
            'ema': {'enabled': True, 'periods': [49, 187]},
            'rsi': {'enabled': True, 'period': 20, 'oversold': 30, 'overbought': 70},
            'bb': {'enabled': True, 'period': 24, 'std_dev': 2.0},
            'atr': {'enabled': True, 'period': 14},
            'adx': {'enabled': True, 'period': 14},
            'fibonacci': {'enabled': False},
            'macd': {'enabled': False, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9},
            'obv': {'enabled': False},
            'stochastic': {'enabled': False, 'k_period': 14, 'd_period': 3},
            'cmf': {'enabled': False, 'period': 21}
        }
        print('‚ö†Ô∏è Using manually defined best configuration as fallback')

    # Calculate Buy & Hold performance
    print('Calculating Buy & Hold performance...')
    bh = calculate_buy_hold_performance('BTC/USDT', 'kraken', '1h')
    print(f'üìä Buy & Hold Performance (Benchmark): {bh:.2f}%')
    print()

    try:
        # Set to discovery mode
        print('Setting discovery mode...')
        settings.CONFIG_MODE = 'discovery'

        # Create temporary adaptive config file with best configuration
        temp_config = {
            'best_configuration': best_config,
            'fitness_score': discovery_data['top_configurations'][0]['fitness_score'] if 'discovery_data' in locals() else 7666.45,
            'timestamp': '2025-10-14T11:23:27'
        }

        # Write to temporary file
        temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False)
        json.dump(temp_config, temp_file, indent=4)
        temp_file.close()

        # Set the adaptive config file path
        settings.ADAPTIVE_CONFIG_FILE = temp_file.name
        print(f'Adaptive config file set to: {temp_file.name}')

        # For traditional strategy, we need to modify the backtester to use traditional strategy
        # Let's try a direct approach - create backtester instance and call with traditional strategy
        from services.backtester import Backtester
        backtester = Backtester(
            symbol='BTC/USDT',
            timeframe='1h',
            start_date='2024-01-01',
            end_date='2025-10-14',
            config=best_config
        )
        
        # Debug by calling methods individually instead of run_backtest
        print("üîç Debugging step by step...")
        try:
            data = backtester._fetch_data()
            print(f"‚úÖ Data fetched: {len(data)} rows")
            
            data = backtester._prepare_traditional_signals(data)
            print(f"‚úÖ Signals prepared: {data['Buy_Signal'].sum()} buy, {data['Sell_Signal'].sum()} sell")
            
            trades = backtester._simulate_trades(data)
            backtester.trades = trades
            print(f"‚úÖ Trades simulated: {len(trades)} trades")
            
            # Check if trades have valid P&L
            if trades:
                pnl_values = [t.get('pnl', 0) for t in trades]
                print(f"P&L values sample: {pnl_values[:5]}")
                nan_count = sum(1 for p in pnl_values if pd.isna(p))
                print(f"NaN in P&L: {nan_count} out of {len(pnl_values)}")
            
            metrics = backtester._calculate_metrics()
            print(f"‚úÖ Metrics calculated: {metrics}")
            
            # Create results dict manually
            results = {
                'backtest_results': {
                    'success': True,
                    'metrics': metrics,
                    'trades': trades,
                    'trades_count': len(trades)
                }
            }
            
        except Exception as debug_e:
            print(f"‚ùå Debug error: {debug_e}")
            import traceback
            traceback.print_exc()
            return

        print('üìä Backtest Results:')
        if 'backtest_results' in results and 'error' not in results['backtest_results']:
            metrics = results['backtest_results']['metrics']
            print(f'Total Trades: {metrics.get("total_trades", 0)}')
            print(f'Win Rate: {metrics.get("win_rate", 0)}%')
            print(f'Total P&L: ${metrics.get("total_pnl", 0):.2f}')
            print(f'Max Drawdown: {metrics.get("max_drawdown", 0):.2f}%')
            print(f'Sharpe Ratio: {metrics.get("sharpe_ratio", 0):.2f}')
            print(f'CAGR: {metrics.get("cagr", 0) if not pd.isna(metrics.get("cagr", 0)) else 0:.2f}%')
            print(f'Final Capital: ${metrics.get("final_capital", 0):.2f}')

            # Compare with Buy & Hold
            backtest_pnl = metrics.get('total_pnl', 0) / 10000 * 100  # Convert to percentage
            vs_benchmark = backtest_pnl - bh
            print()
            print('üèÜ Performance Comparison:')
            print(f'Backtest P&L: {backtest_pnl:.2f}%')
            print(f'Buy & Hold: {bh:.2f}%')
            print(f'vs Benchmark: {vs_benchmark:+.2f}% ({"üöÄ BETTER" if vs_benchmark > 0 else "worse"})')

            if vs_benchmark > 0:
                print('üéâ SUCCESS: Configuration outperforms Buy & Hold!')
            else:
                print('üìâ Configuration underperforms Buy & Hold')

        else:
            error_msg = results.get('backtest_results', {}).get('error', 'Unknown error')
            print(f'‚ùå Backtest failed: {error_msg}')

    except Exception as e:
        print(f'‚ùå Backtest error: {e}')
        import traceback
        traceback.print_exc()

    finally:
        # Restore original settings
        settings.CONFIG_MODE = original_config_mode
        settings.ADAPTIVE_CONFIG_FILE = original_adaptive_config_file
        settings.ML_ENABLED = original_ml_enabled

        # Clean up temporary file
        try:
            os.unlink(temp_file.name)
        except:
            pass

if __name__ == '__main__':
    main()