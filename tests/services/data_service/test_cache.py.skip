"""
Test cache functionality for the trading indicator system.
Tests caching utilities, decorators, and cache management.
"""

import os
import pickle
import shutil
import tempfile
import time
from datetime import datetime, timedelta
from unittest.mock import patch, mock_open
import pytest
import pandas as pd

from services.cache import (
    Cache, cache_indicators, cache_api_call, clear_all_caches,
    get_cache_stats, _indicator_cache, _api_cache
)


class TestCache:
    """Test the Cache class functionality."""

    def setup_method(self):
        """Set up test environment."""
        self.temp_dir = tempfile.mkdtemp()
        self.cache = Cache(cache_dir=self.temp_dir, ttl_seconds=1)  # 1 second TTL for testing

    def teardown_method(self):
        """Clean up test environment."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_cache_initialization(self):
        """Test cache initialization creates directory."""
        assert os.path.exists(self.temp_dir)
        assert self.cache.cache_dir == self.temp_dir
        assert self.cache.ttl_seconds == 1

    def test_get_cache_path(self):
        """Test cache path generation."""
        key = "test_key"
        path = self.cache._get_cache_path(key)
        assert path.startswith(self.temp_dir)
        assert path.endswith('.pkl')
        # Same key should generate same path
        path2 = self.cache._get_cache_path(key)
        assert path == path2

    def test_is_expired_nonexistent_file(self):
        """Test expiration check for non-existent file."""
        assert self.cache._is_expired("nonexistent.pkl")

    def test_is_expired_expired_file(self):
        """Test expiration check for expired file."""
        # Create a file older than TTL
        old_file = os.path.join(self.temp_dir, "old.pkl")
        with open(old_file, 'w') as f:
            f.write("test")

        # Set modification time to 2 seconds ago
        old_time = time.time() - 2
        os.utime(old_file, (old_time, old_time))

        assert self.cache._is_expired(old_file)

    def test_is_expired_valid_file(self):
        """Test expiration check for valid file."""
        # Create a recent file
        new_file = os.path.join(self.temp_dir, "new.pkl")
        with open(new_file, 'w') as f:
            f.write("test")

        assert not self.cache._is_expired(new_file)

    def test_set_and_get_basic_value(self):
        """Test basic set and get operations."""
        key = "test_key"
        value = "test_value"

        self.cache.set(key, value)
        retrieved = self.cache.get(key)

        assert retrieved == value

    def test_set_and_get_complex_value(self):
        """Test set and get with complex data structures."""
        key = "complex_key"
        value = {
            "data": pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]}),
            "metadata": {"timestamp": datetime.now(), "version": "1.0"}
        }

        self.cache.set(key, value)
        retrieved = self.cache.get(key)

        assert isinstance(retrieved, dict)
        assert "data" in retrieved
        assert "metadata" in retrieved
        pd.testing.assert_frame_equal(retrieved["data"], value["data"])
        assert retrieved["metadata"]["version"] == "1.0"

    def test_get_expired_value(self):
        """Test that expired values are not returned."""
        key = "expired_key"
        value = "expired_value"

        self.cache.set(key, value)

        # Wait for expiration
        time.sleep(1.1)

        retrieved = self.cache.get(key)
        assert retrieved is None

    def test_get_nonexistent_key(self):
        """Test getting a key that was never set."""
        retrieved = self.cache.get("nonexistent")
        assert retrieved is None

    def test_clear_cache(self):
        """Test clearing the cache."""
        # Set multiple values
        self.cache.set("key1", "value1")
        self.cache.set("key2", "value2")

        # Verify they exist
        assert self.cache.get("key1") == "value1"
        assert self.cache.get("key2") == "value2"

        # Clear cache
        self.cache.clear()

        # Verify they are gone
        assert self.cache.get("key1") is None
        assert self.cache.get("key2") is None

    def test_corrupted_cache_file(self):
        """Test handling of corrupted cache files."""
        key = "corrupted_key"
        cache_path = self.cache._get_cache_path(key)

        # Create corrupted file
        with open(cache_path, 'w') as f:
            f.write("corrupted data")

        retrieved = self.cache.get(key)
        assert retrieved is None


class TestCacheDecorators:
    """Test caching decorators."""

    def setup_method(self):
        """Set up test environment."""
        clear_all_caches()

    def teardown_method(self):
        """Clean up test environment."""
        clear_all_caches()

    def test_cache_indicators_decorator(self):
        """Test the cache_indicators decorator."""
        call_count = 0

        @cache_indicators(ttl_seconds=60)
        def expensive_calculation(x, y):
            nonlocal call_count
            call_count += 1
            return x + y

        # First call should execute function
        result1 = expensive_calculation(2, 3)
        assert result1 == 5
        assert call_count == 1

        # Second call with same args should use cache
        result2 = expensive_calculation(2, 3)
        assert result2 == 5
        assert call_count == 1  # Should not have increased

        # Call with different args should execute again
        result3 = expensive_calculation(3, 4)
        assert result3 == 7
        assert call_count == 2

    def test_cache_api_call_decorator(self):
        """Test the cache_api_call decorator."""
        call_count = 0

        @cache_api_call(ttl_seconds=30)
        def api_call(endpoint, params=None):
            nonlocal call_count
            call_count += 1
            return {"data": f"response_from_{endpoint}", "params": params}

        # First call should execute function
        result1 = api_call("test_endpoint", {"key": "value"})
        assert result1["data"] == "response_from_test_endpoint"
        assert call_count == 1

        # Second call with same args should use cache
        result2 = api_call("test_endpoint", {"key": "value"})
        assert result2 == result1
        assert call_count == 1

    def test_cache_key_generation(self):
        """Test that cache keys are generated correctly."""
        @cache_indicators()
        def test_func(a, b, c=None):
            return a + b + (c or 0)

        # Same arguments should generate same result
        result1 = test_func(1, 2, c=3)
        result2 = test_func(1, 2, c=3)
        assert result1 == result2

        # Different arguments should generate different results
        result3 = test_func(1, 2, c=4)
        assert result3 != result1


class TestCacheManagement:
    """Test cache management functions."""

    def setup_method(self):
        """Set up test environment."""
        clear_all_caches()

    def teardown_method(self):
        """Clean up test environment."""
        clear_all_caches()

    def test_clear_all_caches(self):
        """Test clearing all caches."""
        # Add some data to both caches
        _indicator_cache.set("indicator_key", "indicator_value")
        _api_cache.set("api_key", "api_value")

        # Verify data exists
        assert _indicator_cache.get("indicator_key") == "indicator_value"
        assert _api_cache.get("api_key") == "api_value"

        # Clear all caches
        clear_all_caches()

        # Verify data is gone
        assert _indicator_cache.get("indicator_key") is None
        assert _api_cache.get("api_key") is None

    def test_get_cache_stats(self):
        """Test getting cache statistics."""
        # Clear caches first
        clear_all_caches()

        # Add some test data
        _indicator_cache.set("indicator1", "value1")
        _indicator_cache.set("indicator2", "value2")
        _api_cache.set("api1", "value1")

        stats = get_cache_stats()

        assert "indicator_cache_size" in stats
        assert "api_cache_size" in stats
        assert stats["indicator_cache_size"] >= 2  # At least our test data
        assert stats["api_cache_size"] >= 1

    def test_get_cache_stats_empty_cache(self):
        """Test cache stats with empty cache."""
        clear_all_caches()

        stats = get_cache_stats()

        assert stats["indicator_cache_size"] == 0
        assert stats["api_cache_size"] == 0


class TestCacheErrorHandling:
    """Test error handling in cache operations."""

    def test_cache_set_with_invalid_data(self):
        """Test caching data that cannot be pickled."""
        cache = Cache(ttl_seconds=60)

        # Try to cache an unpicklable object
        class Unpicklable:
            def __getstate__(self):
                raise TypeError("Cannot pickle this object")

        unpicklable = Unpicklable()
        # This should raise an exception (handled internally by try/catch, but exception still propagates)
        with pytest.raises(TypeError):
            cache.set("unpicklable", unpicklable)

    @patch('os.makedirs')
    def test_cache_initialization_failure(self, mock_makedirs):
        """Test cache initialization when directory creation fails."""
        mock_makedirs.side_effect = OSError("Permission denied")

        # This should not raise an exception (handled internally)
        with pytest.raises(OSError):
            Cache(cache_dir="/invalid/path")

    @patch('builtins.open')
    @patch('pickle.load')
    def test_cache_get_corrupted_pickle(self, mock_pickle_load, mock_file):
        """Test handling of corrupted pickle data."""
        mock_pickle_load.side_effect = pickle.PickleError("Corrupted data")

        cache = Cache(ttl_seconds=60)
        result = cache.get("corrupted_key")

        assert result is None